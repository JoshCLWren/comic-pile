{% extends "base.html" %}

{% block content %}
<style>
    body { padding-bottom: 0 !important; }
    main { padding: 0 !important; height: calc(100dvh - 5rem); max-width: 100%; }
</style>

<div class="h-full flex flex-col overflow-hidden">
    <header class="flex justify-between items-center px-3 py-2 shrink-0 z-10">
        <div>
            <h1 class="text-2xl font-black tracking-tighter text-glow uppercase">Pile Roller</h1>
            <p class="text-[9px] font-bold text-slate-500 uppercase tracking-widest">Active session</p>
        </div>
        <div class="flex items-center gap-2 px-3 py-1 bg-white/5 rounded-xl border border-white/10 shrink-0">
            <div id="header-die-container" class="threejs-dice-container" style="width: 40px; height: 40px;"></div>
            <div class="text-right">
                <span class="block text-[8px] font-black text-slate-500 uppercase tracking-wider">Ladder</span>
                <span id="header-die-label" class="text-[10px] font-black text-teal-400">d{{ current_die }}</span>
            </div>
        </div>
    </header>

    <div id="result" class="flex-1 overflow-auto flex flex-col" role="region" aria-live="polite">
        <div id="roll-container" class="glass-card flex-1 flex flex-col relative overflow-hidden">
            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-80 h-80 bg-indigo-600/10 rounded-full blur-[120px] pointer-events-none"></div>

            <div id="main-die-wrapper" class="threejs-die-wrapper relative z-10 cursor-pointer shrink-0" style="width: 200px; height: 200px;" onclick="rollTheDie()">
                <canvas id="dice-canvas" class="dice-canvas"></canvas>
            </div>

            <p id="tap-instruction"
                class="text-slate-500 font-black uppercase tracking-[0.5em] text-[9px] animate-pulse shrink-0">Tap Die to
                Roll</p>

            <div id="pool-display" class="flex-1 min-h-0 mt-4 px-4 pb-4 overflow-hidden flex flex-col">
                <div class="flex items-center gap-2 shrink-0">
                    <div class="w-2 h-2 rounded-full bg-teal-500 shadow-[0_0_15px_var(--accent-teal)]"></div>
                    <span class="text-[10px] font-black uppercase tracking-widest text-slate-500">Roll Pool</span>
                </div>
                <div id="pool-threads" class="flex-1 overflow-y-auto mt-2 space-y-2 scrollbar-thin">
                    <div class="h-10 bg-white/5 rounded-xl animate-pulse"></div>
                    <div class="h-10 bg-white/5 rounded-xl animate-pulse"></div>
                </div>
            </div>

            <div id="stale-suggestion" class="px-4 pb-4 shrink-0 hidden transition-all animate-[fade-in_0.5s_ease-out]">
                <div class="px-4 py-3 bg-amber-500/5 border border-amber-500/10 rounded-xl flex items-center gap-3">
                    <div class="w-8 h-8 bg-amber-500/10 rounded-lg flex items-center justify-center shrink-0">
                        <span class="text-sm">‚è≥</span>
                    </div>
                    <div class="flex-1 min-w-0">
                        <p id="stale-text"
                            class="text-[10px] font-bold text-amber-200/70 uppercase tracking-wider leading-relaxed">
                            You haven't touched <span class="text-amber-400 font-black">Title</span> in <span
                                class="text-amber-400 font-black">X</span> days
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="explosion-layer" class="explosion-wrap"></div>

<script>
    console.log('[RollPage] Script Initialization Started');

    const DICE_LADDER = [4, 6, 8, 10, 12, 20];
    const initialDenom = {{ current_die }};
    let rolledResult = null;
    let threadId = null;

    let scene, camera, renderer, world, currentDie;
    let isRolling = false;
    let canvasInitialized = false;

    function initDice(container, dieType, size = 50) {
        if (!window.THREE || !window.CANNON || !window.DiceManager) {
            console.error('[RollPage] Dice libraries not loaded');
            return null;
        }

        const width = container.clientWidth || 200;
        const height = container.clientHeight || 200;

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ 
            canvas: container, 
            antialias: true, 
            alpha: true 
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);

        world = new CANNON.World();
        world.gravity.set(0, -20, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 16;

        DiceManager.setWorld(world);

        const floorBody = new CANNON.Body({ 
            mass: 0, 
            shape: new CANNON.Plane(), 
            material: DiceManager.floorBodyMaterial 
        });
        floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.add(floorBody);

        const dieClass = getDieClass(dieType);
        currentDie = new dieClass({ 
            size: size,
            fontColor: '#ffffff',
            backColor: '#4f46e5'
        });
        scene.add(currentDie.getObject());
        currentDie.getObject().position.y = 2;
        currentDie.updateBodyFromMesh();

        canvasInitialized = true;
        return currentDie;
    }

    function getDieClass(dieType) {
        const dieMap = {
            4: DiceD4,
            6: DiceD6,
            8: DiceD8,
            10: DiceD10,
            12: DiceD12,
            20: DiceD20
        };
        return dieMap[dieType] || DiceD6;
    }

    function rollTheDie() {
        console.log('[RollPage] rollTheDie called');
        if (isRolling) return;

        isRolling = true;
        const instruction = document.getElementById('tap-instruction');
        if (instruction) instruction.textContent = "Rolling...";

        if (currentDie && canvasInitialized) {
            currentDie.resetBody();
            currentDie.getObject().position.set(0, 3, 0);
            currentDie.getObject().quaternion.set(
                (Math.random() * 2 - 1),
                (Math.random() * 2 - 1),
                (Math.random() * 2 - 1),
                (Math.random() * 2 - 1)
            ).normalize();
            currentDie.updateBodyFromMesh();
            currentDie.getObject().body.velocity.set(
                (Math.random() - 0.5) * 10,
                10 + Math.random() * 10,
                (Math.random() - 0.5) * 10
            );
            currentDie.getObject().body.angularVelocity.set(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            );

            setTimeout(() => {
                console.log('[RollPage] Triggering HTMX roll event');
                htmx.trigger('#main-die-wrapper', 'triggerRoll');
            }, 1200);
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        if (canvasInitialized && world && currentDie) {
            world.step(1.0 / 60.0);
            currentDie.updateMeshFromBody();
            renderer.render(scene, camera);
        }
    }

    function createExplosion() {
        const layer = document.getElementById('explosion-layer');
        if (!layer) return;
        const count = 70;
        const x = window.innerWidth / 2;
        const y = window.innerHeight / 2;

        for (let i = 0; i < count; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            const angle = Math.random() * Math.PI * 2;
            const dist = 100 + Math.random() * 400;
            p.style.left = x + 'px';
            p.style.top = y + 'px';
            p.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
            p.style.setProperty('--ty', Math.sin(angle) * dist + 'px');
            p.style.background = i % 2 ? 'var(--accent-teal)' : 'var(--accent-violet)';
            layer.appendChild(p);
            setTimeout(() => p.remove(), 1200);
        }
    }

    async function loadRollPool() {
        try {
            console.log('[RollPage] Loading Roll Pool');
            const res = await fetch('/threads/');
            const threads = await res.json();
            const sessionRes = await fetch('/sessions/current/');
            const session = await sessionRes.json();
            const container = document.getElementById('pool-threads');
            if (!container) return;

            const dieSize = session.current_die || 6;
            const pool = threads.slice(0, dieSize);

            if (pool.length === 0) {
                container.innerHTML = '<div class="text-center py-10 text-slate-600 font-black uppercase tracking-widest text-[10px]">Queue Empty</div>';
                return;
            }

            container.innerHTML = pool.map((t, i) => `
                <div class="flex items-center gap-3 px-4 py-2 bg-white/5 border border-white/5 rounded-xl group transition-all">
                    <span class="text-lg font-black text-white/5 group-hover:text-white/10 transition-colors">${i + 1}</span>
                    <div class="flex-1 min-w-0">
                        <p class="font-black text-slate-300 truncate text-sm">${t.title}</p>
                        <p class="text-[8px] font-black text-slate-500 uppercase tracking-widest">${t.format}</p>
                    </div>
                </div>
            `).join('');
        } catch (e) {
            console.error('[RollPage] Failed to load pool:', e);
        }
    }

    document.body.addEventListener('htmx:afterRequest', (evt) => {
        console.log('[RollPage] HTMX afterRequest target:', evt.detail.target.id, 'Status:', evt.detail.xhr.status);
    });

    function updateRatingDisplay(val) {
        const display = document.getElementById('rating-value');
        const preview = document.getElementById('rating-preview');
        const num = parseFloat(val);
        display.textContent = num.toFixed(1);

        let predictedDie = initialDenom;
        if (num >= 4.0) {
            display.className = 'text-teal-400';
            const idx = DICE_LADDER.indexOf(initialDenom);
            predictedDie = idx > 0 ? DICE_LADDER[idx - 1] : DICE_LADDER[0];
            preview.innerHTML = 'Excellent! Die steps down üé≤ Move to front';
        } else {
            display.className = 'text-indigo-400';
            const idx = DICE_LADDER.indexOf(initialDenom);
            predictedDie = idx < DICE_LADDER.length - 1 ? DICE_LADDER[idx + 1] : DICE_LADDER[DICE_LADDER.length - 1];
            preview.innerHTML = 'Okay. Die steps up üé≤ Move to back';
        }

        if (currentDie && canvasInitialized && dieResultContainer) {
            initDice(dieResultContainer, predictedDie, 40);
        }
    }

    async function submitRating() {
        const ratingInput = document.getElementById('rating-input');
        const rating = ratingInput ? parseFloat(ratingInput.value) : 4.0;
        const btn = document.getElementById('submit-rating-btn');
        const errorDisplay = document.getElementById('error-message');

        console.log('[RollPage] submitRating START:', rating);
        if (rating >= 4.0) createExplosion();

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner mx-auto"></span>';
        if (errorDisplay) errorDisplay.classList.add('hidden');

        try {
            const res = await fetch('/rate/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rating, issues_read: 1 })
            });
            console.log('[RollPage] Response status:', res.status);
            if (res.ok) {
                setTimeout(() => window.location.href = '/roll', 1200);
            } else {
                const errData = await res.json();
                if (errorDisplay) {
                    errorDisplay.textContent = errData.detail || "Error saving rating";
                    errorDisplay.classList.remove('hidden');
                }
                btn.disabled = false;
                btn.textContent = 'Retry';
            }
        } catch (e) {
            console.error('[RollPage] submitRating FATAL:', e);
            btn.disabled = false;
            btn.innerHTML = 'Network Error! Retry?';
        }
    }

    async function loadStaleSuggestion() {
        try {
            console.log('[RollPage] Checking for stale threads');
            const res = await fetch('/threads/stale?days=7');
            const staleThreads = await res.json();
            const container = document.getElementById('stale-suggestion');
            const textSpan = document.getElementById('stale-text');

            if (staleThreads && staleThreads.length > 0) {
                const thread = staleThreads[0];
                const lastActivity = thread.last_activity_at ? new Date(thread.last_activity_at) : new Date(thread.created_at);
                const diffMs = new Date() - lastActivity;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                if (diffDays >= 7) {
                    textSpan.innerHTML = `You haven't touched <span class="text-amber-400 font-black">${thread.title}</span> in <span class="text-amber-400 font-black">${diffDays}</span> days`;
                    container.classList.remove('hidden');
                }
            }
        } catch (e) {
            console.error('[RollPage] Failed to load stale suggestion:', e);
        }
    }

    let dieResultContainer = null;

    document.addEventListener('DOMContentLoaded', () => {
        console.log('[RollPage] DOMContentLoaded');
        
        const mainCanvas = document.getElementById('dice-canvas');
        if (mainCanvas) {
            initDice(mainCanvas, initialDenom, 50);
            animate();
        }

        const headerContainer = document.getElementById('header-die-container');
        if (headerContainer && window.DiceManager) {
            const canvas = document.createElement('canvas');
            canvas.className = 'mini-dice-canvas';
            headerContainer.appendChild(canvas);
            initDice(canvas, initialDenom, 15);
        }

        loadRollPool();
        loadStaleSuggestion();
    });
</script>
{% endblock %}
