{% extends "base.html" %}

{% block content %}
<style>
    body { padding-bottom: 0 !important; }
    main { padding: 0 !important; max-width: 100%; }

    .tooltip-container {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 2px;
        cursor: help;
    }

    .tooltip-icon {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(148, 163, 184, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.5);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        font-weight: bold;
        color: rgba(148, 163, 184, 0.7);
        transition: all 0.2s;
    }

    .tooltip-icon:hover {
        background: rgba(20, 184, 166, 0.2);
        border-color: rgba(20, 184, 166, 0.5);
        color: rgba(20, 184, 166, 0.8);
    }

    .tooltip-content {
        position: absolute;
        bottom: 100%;
        right: 0;
        margin-bottom: 8px;
        width: 200px;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 10px;
        font-size: 9px;
        font-weight: normal;
        line-height: 1.4;
        color: rgba(203, 213, 225, 0.9);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        backdrop-filter: blur(8px);
        z-index: 100;
        pointer-events: none;
    }

    .tooltip-content::after {
        content: '';
        position: absolute;
        top: 100%;
        right: 20px;
        margin-top: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: rgba(15, 23, 42, 0.95) transparent transparent transparent;
    }

    .tooltip-container:hover .tooltip-content {
        opacity: 1;
        visibility: visible;
    }

    .tooltip-content strong {
        color: rgba(45, 212, 191, 0.9);
        font-weight: 600;
    }

    .dice-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
        padding: 1rem;
    }

    .dice-wrapper {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
    }

    .dice-container {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.02);
        border: 2px solid rgba(255, 255, 255, 0.05);
        transition: all 0.3s ease;
    }

    .dice-container.selected {
        border-color: rgba(251, 191, 36, 0.8);
        box-shadow: 0 0 40px rgba(251, 191, 36, 0.4), inset 0 0 0 3px rgba(251, 191, 36, 0.3);
        transform: scale(1.4);
        z-index: 10;
    }

    .dice-container.ladder-active {
        border-color: rgba(20, 184, 166, 0.6);
        box-shadow: 0 0 25px rgba(20, 184, 166, 0.25);
        transform: scale(1.05);
    }

    .dice-number {
        position: absolute;
        font-size: 0.75rem;
        font-weight: 900;
        color: rgba(148, 163, 184, 0.5);
        pointer-events: none;
    }

    .dice-number.selected {
        color: rgba(251, 191, 36, 0.9);
        font-size: 0.9rem;
    }

    .thread-preview {
        margin-top: 0.5rem;
        padding: 0.5rem 0.75rem;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 0.5rem;
        text-align: center;
        transition: all 0.2s ease;
        max-width: 100%;
    }

    .thread-preview.selected {
        background: rgba(251, 191, 36, 0.1);
        border-color: rgba(251, 191, 36, 0.3);
    }

    .thread-preview-title {
        font-size: 0.7rem;
        font-weight: 700;
        color: rgba(203, 213, 225, 0.8);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .thread-preview-format {
        font-size: 0.6rem;
        font-weight: 700;
        color: rgba(148, 163, 184, 0.5);
        text-transform: uppercase;
        letter-spacing: 0.1em;
    }

    @media (max-width: 640px) {
        .dice-grid {
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            padding: 0.5rem;
        }

        .dice-container.selected {
            transform: scale(1.25);
        }

        .dice-container.ladder-active {
            transform: scale(1.0);
        }

        .thread-preview-title {
            font-size: 0.6rem;
        }

        .dice-number {
            font-size: 0.65rem;
        }
    }
</style>

<div class="h-screen flex flex-col overflow-hidden">
    <header class="flex justify-between items-center px-3 py-2 shrink-0 z-10">
        <div class="flex items-center gap-3">
            <div>
                <h1 class="text-xl font-black tracking-tighter text-glow uppercase">Roll</h1>
            </div>
            <div class="flex items-center gap-1 px-2 py-1 bg-white/5 rounded-lg border border-white/10">
                <span class="text-[9px] font-black text-slate-500 uppercase">d{{ current_die }}</span>
            </div>
        </div>
        <div class="flex items-center gap-2">
            <div id="session-safe-indicator" class="hidden flex items-center gap-1 px-2 py-1 bg-teal-500/10 border border-teal-500/20 rounded-lg">
                <span class="text-xs">üõ°Ô∏è</span>
                <span class="text-[9px] font-black text-teal-400 uppercase">Session Safe</span>
            </div>
            <div class="relative" id="die-selector">
                <button
                    hx-post="/roll/set-die?die=4"
                    hx-target="#current-die-label"
                    hx-swap="innerText"
                    class="die-btn px-1.5 py-0.5 text-[9px] font-black bg-white/5 rounded border border-white/10 hover:bg-white/10 transition-colors"
                    data-die="4">4</button>
                <button
                    hx-post="/roll/set-die?die=6"
                    hx-target="#current-die-label"
                    hx-swap="innerText"
                    class="die-btn px-1.5 py-0.5 text-[9px] font-black bg-white/5 rounded border border-white/10 hover:bg-white/10 transition-colors"
                    data-die="6">6</button>
                <button
                    hx-post="/roll/set-die?die=8"
                    hx-target="#current-die-label"
                    hx-swap="innerText"
                    class="die-btn px-1.5 py-0.5 text-[9px] font-black bg-white/5 rounded border border-white/10 hover:bg-white/10 transition-colors"
                    data-die="8">8</button>
                <button
                    hx-post="/roll/set-die?die=10"
                    hx-target="#current-die-label"
                    hx-swap="innerText"
                    class="die-btn px-1.5 py-0.5 text-[9px] font-black bg-white/5 rounded border border-white/10 hover:bg-white/10 transition-colors"
                    data-die="10">10</button>
                <button
                    hx-post="/roll/set-die?die=12"
                    hx-target="#current-die-label"
                    hx-swap="innerText"
                    class="die-btn px-1.5 py-0.5 text-[9px] font-black bg-white/5 rounded border border-white/10 hover:bg-white/10 transition-colors"
                    data-die="12">12</button>
                <button
                    hx-post="/roll/set-die?die=20"
                    hx-target="#current-die-label"
                    hx-swap="innerText"
                    class="die-btn px-1.5 py-0.5 text-[9px] font-black bg-white/5 rounded border border-white/10 hover:bg-white/10 transition-colors"
                    data-die="20">20</button>
                <button
                    hx-post="/roll/clear-manual-die"
                    hx-target="#current-die-label"
                    hx-swap="innerText"
                    id="auto-mode-btn"
                    class="px-1.5 py-0.5 text-[9px] font-black bg-white/5 rounded border border-white/10 hover:bg-white/10 transition-colors"
                    title="Return to automatic dice ladder mode">Auto</button>
            </div>
        </div>
    </header>

    <div id="result" class="flex-1 overflow-auto flex flex-col" role="region" aria-live="polite">
        {{ pending_html|safe }}
        <div id="roll-container" class="glass-card flex-1 flex flex-col relative overflow-hidden">
            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-80 h-80 bg-indigo-600/10 rounded-full blur-[120px] pointer-events-none"></div>

            <div id="dice-grid" class="dice-grid flex-1 min-h-0">
            </div>

            <div id="tap-instruction"
                class="text-center text-slate-500 font-black uppercase tracking-[0.5em] text-[9px] animate-pulse py-4 shrink-0">
                Tap Anywhere to Roll
            </div>

            <div id="stale-suggestion" class="px-4 pb-4 shrink-0 hidden transition-all animate-[fade-in_0.5s_ease-out]">
                <div class="px-4 py-3 bg-amber-500/5 border border-amber-500/10 rounded-xl flex items-center gap-3">
                    <div class="w-8 h-8 bg-amber-500/10 rounded-lg flex items-center justify-center shrink-0">
                        <span class="text-sm">‚è≥</span>
                    </div>
                    <div class="flex-1 min-w-0">
                        <p id="stale-text"
                            class="text-[10px] font-bold text-amber-200/70 uppercase tracking-wider leading-relaxed">
                            You haven't touched <span class="text-amber-400 font-black">Title</span> in <span
                                class="text-amber-400 font-black">X</span> days
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="explosion-layer" class="explosion-wrap"></div>

<script>
    console.log('[RollPage] Script Initialization Started');

    const DICE_LADDER = [4, 6, 8, 10, 12, 20];
    const initialDenom = {{ current_die }};
    let rolledResult = null;
    let threadId = null;
    let isRolling = false;
    let currentDieValue = 1;
    let diceInstances = {};
    let selectedThreadId = localStorage.getItem('selectedThreadId') || null;

    function setDiceState(state) {
        console.log('[RollPage] Dice state set to:', state);
    }

    function initDice() {
        if (window.Dice3D) {
            Dice3D.cleanup();
        }

        const grid = document.getElementById('dice-grid');
        if (!grid) return;

        grid.innerHTML = '';

        for (let i = 1; i <= initialDenom; i++) {
            const wrapper = document.createElement('div');
            wrapper.className = 'dice-wrapper';
            wrapper.id = `dice-wrapper-${i}`;

            const container = document.createElement('div');
            container.className = 'dice-container';
            container.style.width = '80px';
            container.style.height = '80px';
            container.id = `dice-container-${i}`;

            const die3dContainer = document.createElement('div');
            die3dContainer.className = 'w-full h-full';
            die3dContainer.id = `die-3d-${i}`;

            const numberLabel = document.createElement('div');
            numberLabel.className = 'dice-number';
            numberLabel.textContent = i;

            const threadPreview = document.createElement('div');
            threadPreview.className = 'thread-preview';
            threadPreview.id = `thread-preview-${i}`;
            threadPreview.innerHTML = `
                <div class="thread-preview-title">...</div>
                <div class="thread-preview-format">Loading</div>
            `;

            container.appendChild(die3dContainer);
            container.appendChild(numberLabel);
            wrapper.appendChild(container);
            wrapper.appendChild(threadPreview);
            grid.appendChild(wrapper);

            const die = window.Dice3D ? Dice3D.create(die3dContainer, initialDenom, { color: 0xffffff, showValue: false }) : null;
            if (die) die.setValue(i);
            diceInstances[i] = die;
        }

        updateDieButtonState(initialDenom);
        setDiceState('idle');
        loadRollPool();
    }

    function updateDieButtonState(die) {
        const buttons = document.querySelectorAll('.die-btn');
        buttons.forEach(btn => {
            const btnDie = parseInt(btn.getAttribute('data-die'));
            if (btnDie === die) {
                btn.classList.remove('bg-white/5');
                btn.classList.add('bg-teal-500/20', 'border-teal-500', 'text-teal-400');
            } else {
                btn.classList.remove('bg-teal-500/20', 'border-teal-500', 'text-teal-400');
                btn.classList.add('bg-white/5');
            }
        });

        const autoBtn = document.getElementById('auto-mode-btn');
        if (autoBtn) {
            autoBtn.classList.remove('bg-amber-500/20', 'border-amber-500', 'text-amber-400');
            autoBtn.classList.add('bg-white/5');
            autoBtn.title = 'Return to automatic dice ladder mode';
        }
    }

    function rollTheDie() {
        console.log('[RollPage] rollTheDie called');
        if (isRolling) return;

        localStorage.removeItem('selectedThreadId');
        selectedThreadId = null;

        isRolling = true;
        setDiceState('idle');
        const instruction = document.getElementById('tap-instruction');
        if (instruction) instruction.textContent = 'Rolling...';

        let rollCount = 0;
        const maxRolls = 10;
        const rollInterval = setInterval(() => {
            rollCount++;

            if (rollCount >= maxRolls) {
                clearInterval(rollInterval);
                setTimeout(() => {
                    console.log('[RollPage] Triggering HTMX roll event');
                    htmx.trigger('#roll-container', 'triggerRoll');
                }, 400);
            }
        }, 80);
    }

    function createExplosion() {
        const layer = document.getElementById('explosion-layer');
        if (!layer) return;
        const count = 70;
        const x = window.innerWidth / 2;
        const y = window.innerHeight / 2;

        for (let i = 0; i < count; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            const angle = Math.random() * Math.PI * 2;
            const dist = 100 + Math.random() * 400;
            p.style.left = x + 'px';
            p.style.top = y + 'px';
            p.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
            p.style.setProperty('--ty', Math.sin(angle) * dist + 'px');
            p.style.background = i % 2 ? 'var(--accent-teal)' : 'var(--accent-violet)';
            layer.appendChild(p);
            setTimeout(() => p.remove(), 1200);
        }
    }

    async function loadRollPool() {
        try {
            console.log('[RollPage] Loading Roll Pool');
            const res = await fetch('/threads/');
            const threads = await res.json();
            const sessionRes = await fetch('/sessions/current/');
            const session = await sessionRes.json();
            const dieSize = session.current_die || 6;
            const pool = threads.slice(0, dieSize);

            for (let i = 0; i < dieSize; i++) {
                const threadPreview = document.getElementById(`thread-preview-${i + 1}`);
                if (threadPreview) {
                    if (i < pool.length) {
                        const t = pool[i];
                        const isSelected = selectedThreadId && parseInt(selectedThreadId) === t.id;
                        threadPreview.className = 'thread-preview' + (isSelected ? ' selected' : '');
                        threadPreview.innerHTML = `
                            <div class="thread-preview-title">${t.title}</div>
                            <div class="thread-preview-format">${t.format}</div>
                        `;
                    } else {
                        threadPreview.className = 'thread-preview';
                        threadPreview.innerHTML = `
                            <div class="thread-preview-title text-slate-600">Empty</div>
                            <div class="thread-preview-format">--</div>
                        `;
                    }
                }
            }
        } catch (e) {
            console.error('[RollPage] Failed to load pool:', e);
        }
    }

    document.body.addEventListener('htmx:afterRequest', (evt) => {
        console.log('[RollPage] HTMX afterRequest target:', evt.detail.target.id, 'Status:', evt.detail.xhr.status);
        const target = evt.detail.target.id;

        if (target === 'current-die-label' && evt.detail.xhr.status === 200) {
            const newDie = parseInt(evt.detail.target.innerText.replace('d', ''));
            updateDieButtonState(newDie);
            initDice();
        }
    });

    function updateRatingDisplay(val) {
        const display = document.getElementById('rating-value');
        const preview = document.getElementById('rating-preview');
        const num = parseFloat(val);
        display.textContent = num.toFixed(1);

        let predictedDie = initialDenom;
        if (num >= 4.0) {
            display.className = 'text-teal-400';
            const idx = DICE_LADDER.indexOf(initialDenom);
            if (idx > 0) {
                predictedDie = DICE_LADDER[idx - 1];
                preview.innerHTML = 'Excellent! Die steps down üé≤ Move to front';
            } else {
                predictedDie = DICE_LADDER[0];
                preview.innerHTML = 'Already at minimum üé≤ Die stays at d4';
            }
        } else {
            display.className = 'text-indigo-400';
            const idx = DICE_LADDER.indexOf(initialDenom);
            if (idx < DICE_LADDER.length - 1) {
                predictedDie = DICE_LADDER[idx + 1];
                preview.innerHTML = 'Okay. Die steps up üé≤ Move to back';
            } else {
                predictedDie = DICE_LADDER[DICE_LADDER.length - 1];
                preview.innerHTML = 'Already at maximum üé≤ Die stays at d20';
            }
        }
    }

    async function submitRating() {
        const ratingInput = document.getElementById('rating-input');
        const rating = ratingInput ? parseFloat(ratingInput.value) : 4.0;
        const btn = document.getElementById('submit-rating-btn');
        const errorDisplay = document.getElementById('error-message');

        console.log('[RollPage] submitRating START:', rating);

        const canProceed = await checkRestorePointBeforeSubmit();
        if (!canProceed) {
            btn.disabled = false;
            btn.textContent = 'Save & Continue';
            return;
        }

        if (rating >= 4.0) createExplosion();

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner mx-auto"></span>';
        if (errorDisplay) errorDisplay.classList.add('hidden');

        try {
            const res = await fetch('/rate/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rating, issues_read: 1 })
            });
            console.log('[RollPage] Response status:', res.status);
            if (res.ok) {
                localStorage.removeItem('selectedThreadId');
                setTimeout(() => window.location.href = '/roll', 1200);
            } else {
                const errData = await res.json();
                if (errorDisplay) {
                    errorDisplay.textContent = errData.detail || 'Error saving rating';
                    errorDisplay.classList.remove('hidden');
                }
                btn.disabled = false;
                btn.textContent = 'Retry';
            }
        } catch (e) {
            console.error('[RollPage] submitRating FATAL:', e);
            btn.disabled = false;
            btn.innerHTML = 'Network Error! Retry?';
        }
    }

    async function loadStaleSuggestion() {
        try {
            console.log('[RollPage] Checking for stale threads');
            const res = await fetch('/threads/stale?days=7');
            const staleThreads = await res.json();
            const container = document.getElementById('stale-suggestion');
            const textSpan = document.getElementById('stale-text');

            if (staleThreads && staleThreads.length > 0) {
                const thread = staleThreads[0];
                const lastActivity = thread.last_activity_at ? new Date(thread.last_activity_at) : new Date(thread.created_at);
                const diffMs = new Date() - lastActivity;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                if (diffDays >= 7) {
                    textSpan.innerHTML = `You haven't touched <span class="text-amber-400 font-black">${thread.title}</span> in <span class="text-amber-400 font-black">${diffDays}</span> days`;
                    container.classList.remove('hidden');
                }
            }
        } catch (e) {
            console.error('[RollPage] Failed to load stale suggestion:', e);
        }
    }

    async function checkManualMode() {
        try {
            const res = await fetch('/sessions/current/');
            const session = await res.json();
            const autoBtn = document.getElementById('auto-mode-btn');
            if (!autoBtn) return;

            if (session.manual_die) {
                autoBtn.classList.remove('bg-white/5');
                autoBtn.classList.add('bg-amber-500/20', 'border-amber-500', 'text-amber-400');
                autoBtn.title = 'Exit manual mode (currently ' + session.manual_die + ')';
            } else {
                autoBtn.classList.remove('bg-amber-500/20', 'border-amber-500', 'text-amber-400');
                autoBtn.classList.add('bg-white/5');
                autoBtn.title = 'Return to automatic dice ladder mode';
            }

            const safeIndicator = document.getElementById('session-safe-indicator');
            if (safeIndicator) {
                if (session.has_restore_point) {
                    safeIndicator.classList.remove('hidden');
                    safeIndicator.classList.add('flex');
                } else {
                    safeIndicator.classList.add('hidden');
                    safeIndicator.classList.remove('flex');
                }
            }
        } catch (e) {
            console.error('[RollPage] Failed to check manual mode:', e);
        }
    }

    async function checkRestorePointBeforeSubmit() {
        try {
            const res = await fetch('/sessions/current/');
            const session = await res.json();

            if (!session.has_restore_point) {
                const confirmed = confirm('‚ö†Ô∏è No restore point available!\n\nYou are about to make a destructive action that cannot be undone. Continue anyway?');
                return confirmed;
            }
            return true;
        } catch (e) {
            console.error('[RollPage] Failed to check restore point:', e);
            return true;
        }
    }

    async function triggerReroll() {
        localStorage.removeItem('selectedThreadId');
        selectedThreadId = null;

        const btn = document.getElementById('reroll-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner mx-auto"></span> Rerolling...';
        }

        try {
            const res = await fetch('/roll/reroll', {
                method: 'POST'
            });
            console.log('[RollPage] Reroll response status:', res.status);
            if (res.ok) {
                const html = await res.text();
                document.getElementById('result').innerHTML = html;
            } else {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Reroll Failed. Retry?';
                }
            }
        } catch (e) {
            console.error('[RollPage] triggerReroll FATAL:', e);
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = 'Network Error! Retry?';
            }
        }
    }

    document.getElementById('roll-container').addEventListener('click', (e) => {
        if (!isRolling && !e.target.closest('button') && !e.target.closest('input')) {
            rollTheDie();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        console.log('[RollPage] DOMContentLoaded');

        initDice();
        loadStaleSuggestion();
        checkManualMode();
    });
</script>
{% endblock %}
